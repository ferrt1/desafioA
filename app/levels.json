{
    "1": {
        "titulo": "Nivel 1: Estructuras de Control",
        "items": [
            {
                "id": "else-item",
                "texto": "Else",
                "categoria": "condicional"
            },
            {
                "id": "switch-item",
                "texto": "Switch",
                "categoria": "condicional"
            },
            {
                "id": "ternario-item",
                "texto": "Operador Ternario",
                "categoria": "condicional"
            },
            {
                "id": "for-item",
                "texto": "For",
                "categoria": "bucle"
            },
            {
                "id": "while-item",
                "texto": "While",
                "categoria": "bucle"
            },
            {
                "id": "do-while-item",
                "texto": "Do-While",
                "categoria": "bucle"
            },
            {
                "id": "foreach-item",
                "texto": "ForEach",
                "categoria": "bucle"
            }
        ],
        "boxes": [
            {
                "id": "condicional",
                "texto": "Condicionales"
            },
            {
                "id": "bucle",
                "texto": "Bucles"
            }
        ],
        "hints": [
            "Los condicionales permiten tomar decisiones en el código.",
            "El operador ternario es una forma compacta de escribir un 'if'.",
            "Un 'switch' es útil cuando tienes múltiples opciones basadas en una variable.",
            "Los bucles permiten repetir instrucciones sin escribirlas varias veces.",
            "El bucle 'for' es ideal cuando conoces el número de repeticiones.",
            "El 'while' se ejecuta mientras una condición sea verdadera.",
            "El 'do-while' se ejecuta al menos una vez antes de verificar la condición."
        ]
    },
    "2": {
        "titulo": "Nivel 2: Tipos de Datos",
        "items": [
            {
                "id": "int-item",
                "texto": "Enteros (int)",
                "categoria": "primitivo"
            },
            {
                "id": "float-item",
                "texto": "Punto flotante (float, double)",
                "categoria": "primitivo"
            },
            {
                "id": "boolean-item",
                "texto": "Booleanos (true/false)",
                "categoria": "primitivo"
            },
            {
                "id": "char-item",
                "texto": "Caracteres (char)",
                "categoria": "primitivo"
            },
            {
                "id": "string-item",
                "texto": "Cadenas de texto (string)",
                "categoria": "primitivo"
            },
            {
                "id": "array-item",
                "texto": "Arreglos (Array)",
                "categoria": "complejo"
            },
            {
                "id": "objeto-item",
                "texto": "Objetos (Object)",
                "categoria": "complejo"
            },
            {
                "id": "list-item",
                "texto": "Listas (List)",
                "categoria": "complejo"
            }
        ],
        "boxes": [
            {
                "id": "primitivo",
                "texto": "Tipos Primitivos"
            },
            {
                "id": "complejo",
                "texto": "Tipos Complejos"
            }
        ],
        "hints": [
            "Los tipos primitivos son los más básicos y no pueden descomponerse.",
            "Los enteros se usan para números sin decimales.",
            "Los booleanos representan valores de verdadero o falso.",
            "Los caracteres almacenan un solo símbolo, como 'A' o '9'.",
            "Los arreglos y listas almacenan colecciones de datos.",
            "Los objetos pueden tener múltiples propiedades y métodos."
        ]
    },
    "3": {
        "titulo": "Nivel 4: Paradigmas de Programación",
        "items": [
            {
                "id": "objeto-item",
                "texto": "Objetos",
                "categoria": "poo"
            },
            {
                "id": "clase-item",
                "texto": "Clases",
                "categoria": "poo"
            },
            {
                "id": "herencia-item",
                "texto": "Herencia",
                "categoria": "poo"
            },
            {
                "id": "polimorfismo-item",
                "texto": "Polimorfismo",
                "categoria": "poo"
            },
            {
                "id": "orden-superior-item",
                "texto": "Funciones de Orden Superior",
                "categoria": "funcional"
            },
            {
                "id": "funciones-puras-item",
                "texto": "Funciones Puras",
                "categoria": "funcional"
            },
            {
                "id": "estado-mutable-item",
                "texto": "Estado Mutable",
                "categoria": "imperativa"
            },
            {
                "id": "estructuras-control-item",
                "texto": "Estructuras de Control",
                "categoria": "imperativa"
            }
        ],
        "boxes": [
            {
                "id": "poo",
                "texto": "Programación Orientada a Objetos"
            },
            {
                "id": "funcional",
                "texto": "Programación Funcional"
            },
            {
                "id": "imperativa",
                "texto": "Programación Imperativa"
            }
        ],
        "hints": [
            "La POO se basa en objetos y clases que modelan entidades del mundo real.",
            "La programación imperativa describe el 'cómo' de la ejecución paso a paso.",
            "La herencia permite crear nuevas clases basadas en otras existentes.",
            "El polimorfismo permite que un mismo método funcione de diferentes formas.",
            "La programación funcional trata las funciones como valores y evita estados mutables.",
            "Las funciones puras siempre devuelven el mismo resultado para los mismos parámetros."
        ]
    },
    "4": {
        "titulo": "Nivel 5: Errores y Depuración",
        "items": [
            {
                "id": "sintaxis-item",
                "texto": "No cerrar paréntesis",
                "categoria": "sintaxis"
            },
            {
                "id": "variable-no-declarada-item",
                "texto": "Variable no declarada",
                "categoria": "sintaxis"
            },
            {
                "id": "infinito-item",
                "texto": "Bucle infinito",
                "categoria": "logico"
            },
            {
                "id": "null-item",
                "texto": "Acceso a null",
                "categoria": "logico"
            },
            {
                "id": "test-unitario-item",
                "texto": "Prueba unitaria",
                "categoria": "unitaria"
            },
            {
                "id": "assert-item",
                "texto": "Asserts",
                "categoria": "unitaria"
            }
        ],
        "boxes": [
            {
                "id": "sintaxis",
                "texto": "Errores de Sintaxis"
            },
            {
                "id": "logico",
                "texto": "Errores Lógicos"
            },
            {
                "id": "unitaria",
                "texto": "Pruebas Unitarias"
            }
        ],
        "hints": [
            "Los errores de sintaxis ocurren cuando el código no sigue las reglas del lenguaje.",
            "Los errores lógicos no detienen el programa, pero producen resultados incorrectos.",
            "Las pruebas unitarias ayudan a verificar que el código funciona correctamente.",
            "Los asserts permiten comprobar que el programa cumple con ciertas condiciones."
        ]
    }
}