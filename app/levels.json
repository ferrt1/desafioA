{
    "1": {
        "titulo": "Nivel 1: Estructuras de Control",
        "items": [
            {
                "id": "else-item",
                "texto": "Else",
                "categoria": "condicional"
            },
            {
                "id": "switch-item",
                "texto": "Switch",
                "categoria": "condicional"
            },
            {
                "id": "ternario-item",
                "texto": "Operador Ternario",
                "categoria": "condicional"
            },
            {
                "id": "for-item",
                "texto": "For",
                "categoria": "bucle"
            },
            {
                "id": "while-item",
                "texto": "While",
                "categoria": "bucle"
            },
            {
                "id": "do-while-item",
                "texto": "Do-While",
                "categoria": "bucle"
            },
            {
                "id": "foreach-item",
                "texto": "ForEach",
                "categoria": "bucle"
            }
        ],
        "boxes": [
            {
                "id": "condicional",
                "texto": "Condicionales"
            },
            {
                "id": "bucle",
                "texto": "Bucles"
            }
        ],
        "hints": [
            "Los condicionales permiten tomar decisiones en el código.",
            "El operador ternario es una forma compacta de escribir un 'if'.",
            "Un 'switch' es útil cuando tienes múltiples opciones basadas en una variable.",
            "Los bucles permiten repetir instrucciones sin escribirlas varias veces.",
            "El bucle 'for' es ideal cuando conoces el número de repeticiones.",
            "El 'while' se ejecuta mientras una condición sea verdadera.",
            "El 'do-while' se ejecuta al menos una vez antes de verificar la condición."
        ]
    },
    "2": {
        "titulo": "Nivel 2: Tipos de Datos",
        "items": [
            {
                "id": "int-item",
                "texto": "Enteros (int)",
                "categoria": "primitivo"
            },
            {
                "id": "float-item",
                "texto": "Punto flotante (float, double)",
                "categoria": "primitivo"
            },
            {
                "id": "boolean-item",
                "texto": "Booleanos (true/false)",
                "categoria": "primitivo"
            },
            {
                "id": "char-item",
                "texto": "Caracteres (char)",
                "categoria": "primitivo"
            },
            {
                "id": "string-item",
                "texto": "Cadenas de texto (string)",
                "categoria": "primitivo"
            },
            {
                "id": "array-item",
                "texto": "Arreglos (Array)",
                "categoria": "complejo"
            },
            {
                "id": "objeto-item",
                "texto": "Objetos (Object)",
                "categoria": "complejo"
            },
            {
                "id": "list-item",
                "texto": "Listas (List)",
                "categoria": "complejo"
            }
        ],
        "boxes": [
            {
                "id": "primitivo",
                "texto": "Tipos Primitivos"
            },
            {
                "id": "complejo",
                "texto": "Tipos Complejos"
            }
        ],
        "hints": [
            "Los tipos primitivos son los más básicos y no pueden descomponerse.",
            "Los enteros se usan para números sin decimales.",
            "Los booleanos representan valores de verdadero o falso.",
            "Los caracteres almacenan un solo símbolo, como 'A' o '9'.",
            "Los arreglos y listas almacenan colecciones de datos.",
            "Los objetos pueden tener múltiples propiedades y métodos."
        ]
    },
    "3": {
        "titulo": "Nivel 3: Arrays vs Listas",
        "items": [
            {
                "id": "array-item",
                "texto": "Elementos de un mismo tipo",
                "categoria": "arrays"
            },
            {
                "id": "lista-item",
                "texto": "Elementos de diferentes tipos",
                "categoria": "listas"
            },
            {
                "id": "static-item",
                "texto": "Tamaño fijo",
                "categoria": "arrays"
            },
            {
                "id": "dynamic-item",
                "texto": "Tamaño dinámico",
                "categoria": "listas"
            }
        ],
        "boxes": [
            {
                "id": "arrays",
                "texto": "Arrays"
            },
            {
                "id": "listas",
                "texto": "Listas"
            }
        ],
        "hints": [
            "Los arrays contienen elementos de un mismo tipo y tienen tamaño fijo.",
            "Las listas pueden contener elementos de distintos tipos y cambiar de tamaño.",
            "Los arrays son más eficientes en acceso directo, pero menos flexibles.",
            "Las listas permiten agregar y eliminar elementos dinámicamente."
        ]
    },
    "4": {
        "titulo": "Nivel 4: Paradigmas de Programación",
        "items": [
            {
                "id": "objeto-item",
                "texto": "Objetos",
                "categoria": "poo"
            },
            {
                "id": "clase-item",
                "texto": "Clases",
                "categoria": "poo"
            },
            {
                "id": "herencia-item",
                "texto": "Herencia",
                "categoria": "poo"
            },
            {
                "id": "polimorfismo-item",
                "texto": "Polimorfismo",
                "categoria": "poo"
            },
            {
                "id": "orden-superior-item",
                "texto": "Funciones de Orden Superior",
                "categoria": "funcional"
            },
            {
                "id": "funciones-puras-item",
                "texto": "Funciones Puras",
                "categoria": "funcional"
            },
            {
                "id": "lambda-item",
                "texto": "Expresiones lambda",
                "categoria": "funcional"
            }
        ],
        "boxes": [
            {
                "id": "poo",
                "texto": "Programación Orientada a Objetos"
            },
            {
                "id": "funcional",
                "texto": "Programación Funcional"
            }
        ],
        "hints": [
            "La POO se basa en objetos y clases que modelan entidades del mundo real.",
            "La herencia permite crear nuevas clases basadas en otras existentes.",
            "El polimorfismo permite que un mismo método funcione de diferentes formas.",
            "La programación funcional trata las funciones como valores y evita estados mutables.",
            "Las funciones puras siempre devuelven el mismo resultado para los mismos parámetros."
        ]
    },
    "5": {
        "titulo": "Nivel 5: Sobrecarga vs Sobreescritura",
        "items": [
            {
                "id": "sobrecarga-item1",
                "texto": "Método con distintos parámetros",
                "categoria": "sobrecarga"
            },
            {
                "id": "sobrecarga-item2",
                "texto": "Mismo nombre, diferente número de argumentos",
                "categoria": "sobrecarga"
            },
            {
                "id": "sobreescritura-item1",
                "texto": "Método heredado modificado",
                "categoria": "sobreescritura"
            },
            {
                "id": "sobreescritura-item2",
                "texto": "Redefinir comportamiento en una subclase",
                "categoria": "sobreescritura"
            }
        ],
        "boxes": [
            {
                "id": "sobrecarga",
                "texto": "Sobrecarga"
            },
            {
                "id": "sobreescritura",
                "texto": "Sobreescritura"
            }
        ],
        "hints": [
            "La sobrecarga ocurre cuando hay métodos con el mismo nombre pero diferentes parámetros en la misma clase.",
            "La sobreescritura ocurre cuando una subclase redefine un método de su superclase.",
            "La sobrecarga permite varias versiones de un método con distintas entradas.",
            "La sobreescritura permite modificar la funcionalidad heredada."
        ]
    },
    "6": {
        "titulo": "Nivel 6: Interfaz vs Clase Abstracta",
        "items": [
            {
                "id": "interfaz-item1",
                "texto": "Solo define métodos, sin implementación",
                "categoria": "interfaz"
            },
            {
                "id": "interfaz-item2",
                "texto": "Se implementa en múltiples clases",
                "categoria": "interfaz"
            },
            {
                "id": "abstracta-item1",
                "texto": "Puede tener métodos implementados",
                "categoria": "clase-abstracta"
            },
            {
                "id": "abstracta-item2",
                "texto": "Debe ser extendida, no instanciada",
                "categoria": "clase-abstracta"
            }
        ],
        "boxes": [
            {
                "id": "interfaz",
                "texto": "Interfaz"
            },
            {
                "id": "clase-abstracta",
                "texto": "Clase Abstracta"
            }
        ],
        "hints": [
            "Las interfaces solo contienen la declaración de métodos sin implementación.",
            "Las clases abstractas pueden tener tanto métodos implementados como abstractos.",
            "Una clase puede implementar múltiples interfaces, pero solo heredar de una clase abstracta.",
            "Las interfaces permiten definir contratos para múltiples clases."
        ]
    },
    "7": {
        "titulo": "Nivel 7: Tipos de Colecciones",
        "items": [
            {
                "id": "hashmap-item",
                "texto": "Clave-valor (HashMap)",
                "categoria": "mapa"
            },
            {
                "id": "treemap-item",
                "texto": "Ordenado por clave (TreeMap)",
                "categoria": "mapa"
            },
            {
                "id": "hashset-item",
                "texto": "Conjunto sin duplicados (HashSet)",
                "categoria": "conjunto"
            },
            {
                "id": "treeset-item",
                "texto": "Ordenado sin duplicados (TreeSet)",
                "categoria": "conjunto"
            }
        ],
        "boxes": [
            {
                "id": "mapa",
                "texto": "Mapas"
            },
            {
                "id": "conjunto",
                "texto": "Conjuntos"
            }
        ],
        "hints": [
            "Los mapas asocian claves con valores.",
            "Los conjuntos no permiten elementos duplicados."
        ]
    },
    "8": {
        "titulo": "Nivel 8: Errores y Depuración",
        "items": [
            {
                "id": "sintaxis-item",
                "texto": "No cerrar paréntesis",
                "categoria": "sintaxis"
            },
            {
                "id": "variable-no-declarada-item",
                "texto": "Variable no declarada",
                "categoria": "sintaxis"
            },
            {
                "id": "infinito-item",
                "texto": "Bucle infinito",
                "categoria": "logico"
            },
            {
                "id": "null-item",
                "texto": "Acceso a null",
                "categoria": "logico"
            }
        ],
        "boxes": [
            {
                "id": "sintaxis",
                "texto": "Errores de Sintaxis"
            },
            {
                "id": "logico",
                "texto": "Errores Lógicos"
            }
        ],
        "hints": [
            "Los errores de sintaxis ocurren cuando el código no sigue las reglas del lenguaje.",
            "Los errores lógicos no detienen el programa, pero producen resultados incorrectos."
        ]
    },
    "9": {
    "titulo": "Nivel 9: Pruebas Unitarias vs Pruebas Funcionales",
    "items": [
        {
            "id": "prueba-unitaria-item",
            "texto": "Prueba de unidades pequeñas",
            "categoria": "unitarias"
        },
        {
            "id": "prueba-funcional-item",
            "texto": "Prueba del sistema completo",
            "categoria": "funcionales"
        },
        {
            "id": "mock-item",
            "texto": "Se prueban funciones, procedimientos, métodos",
            "categoria": "unitarias"
        },
        {
            "id": "integracion-item",
            "texto": "Se prueban interacciones de usuarios y funcionalidad de extremo a extremo.",
            "categoria": "funcionales"
        }
    ],
    "boxes": [
        {
            "id": "unitarias",
            "texto": "Pruebas Unitarias"
        },
        {
            "id": "funcionales",
            "texto": "Pruebas Funcionales"
        }
    ],
    "hints": [
        "Las pruebas unitarias se enfocan en componentes pequeños y aislados del sistema.",
        "Las pruebas funcionales verifican que el sistema funcione como un todo, simulando la interacción del usuario."
    ]
}
}